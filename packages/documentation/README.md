# Fa
**The universal programming language**

**TypeScript at the speed of Rust.  
Rust with TypeScript’s simplicity.**

Fa is a new programming language designed to replace today’s fragmented toolchains with **one coherent, safe, high-performance language** — from web applications to tooling, systems, and beyond.

---

## One language. Everywhere.

Fa is built to be **universal by design**.

- Web applications  
- Developer tooling & CLIs  
- Servers and backends  
- Embedded & systems software  
- Game engines and simulations  

Write once. Target multiple runtimes.  
No rewrites. No paradigm switches.

---

## A replacement for TypeScript *and* Rust

Today, developers are forced to choose:

- **TypeScript** — productive, but slow and unsafe at runtime  
- **Rust** — fast and safe, but complex and hard to iterate on  

Fa removes that tradeoff.

- The **ergonomics of TypeScript**
- The **performance and safety of Rust**
- Without the downsides of either

---

## Performance without compromise

Fa compiles to efficient low-level code while remaining simple to reason about.

- No runtime garbage collector  
- No hidden costs  
- No unpredictable pauses  

**Predictable performance, by default.**

---

## A new memory model — simple, safe, powerful

Fa introduces a **unique memory management system**.

- ❌ No garbage collector  
- ❌ No complex borrow-checker rules  
- ❌ No lifetime annotations everywhere  

Instead, Fa relies on two core concepts.

### Owned References
Ownership is explicit, local, and intuitive.

### Relations
Lifetimes are expressed declaratively through relationships — not inferred through complex compiler logic.

The result:
- Memory safety by construction  
- A clear mental model  
- Compiler rules you can actually understand  

---

## Built-in reactivity — at the language level

Fa is the **first programming language with reactivity built into its core semantics**.

- No frameworks  
- No hooks  
- No magic conventions  

Reactivity in Fa is:
- statically analyzable  
- type-safe  
- predictable  
- composable  

State changes propagate **because the language understands them**, not because a library tries to guess.

---

## Metaprogramming, without pain

Fa makes metaprogramming **boringly simple**.

- Compile-time execution  
- Code generation without macros-from-hell  
- No separate DSLs  
- No unreadable syntax trees  

If you can write Fa, you can metaprogram in Fa.

---

## One mental model, end to end

Fa eliminates accidental complexity.

- One type system  
- One language  
- One toolchain  
- One way to reason about correctness  

No context switching between:
- “safe vs unsafe”  
- “runtime vs compile-time”  
- “frontend vs backend”  

---

## Designed for humans and AIs. Built for the future.

Fa is:
- Strongly typed
- Statically compiled
- Fully open source
- Vendor-neutral
- Designed for long-term maintainability

This is not an experiment.  
It’s a foundation.

---

## Status

Fa is under active development.

The goal is a **stable v1 focused on web and tooling**, with additional backends following.

If you believe programming languages should be:
- simpler  
- safer  
- faster  
- more unified  

Then Fa is for you.
