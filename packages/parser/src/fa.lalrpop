grammar;

use std::str::FromStr;
use crate::ast::{Expression, Operator, Statement, Program};

match {
	// ignore spaces and tabs
	r"[ \t]*" => { }
} else {
	// precedence of matching tokens
	// in case of ambiguities, longest tokens first
	// else, shortest tokens first
	"*",
	"/",
	"+",
	"-",
	"(",
	")",
	r"[0-9]+" => NUMBER,
	r"[,\n]" => STOP,
	r#"[^\s0-9,;:=?./+%`^¨*&'(!)-_][^\s,;:=?./+%`^¨*&'(!)-]*"# => IDENTIFIER,
}

pub Program: Program = <values: ZeroOrMore<Statement>> => Program(values);

pub Statement: Statement = {
	<SingleExpression> => Statement::Expression(<>),
}

pub Expression: Box<Expression> = {
	List,
	SingleExpression,
}

SingleExpression: Box<Expression> = {
	CallExpression,
	OperationExpression,
}

OperationExpression: Box<Expression> = {
	#[precedence(level="0")]
	Literal,
	Group,
	
	#[precedence(level="30")] #[assoc(side="left")]
	<left:OperationExpression> "*" <right:OperationExpression> => Box::new(Expression::Operation(left, Operator::Multiply, right)),
	<left:OperationExpression> "/" <right:OperationExpression> => Box::new(Expression::Operation(left, Operator::Divide, right)),
	
	#[precedence(level="40")] #[assoc(side="left")]
	<left:OperationExpression> "+" <right:OperationExpression> => Box::new(Expression::Operation(left, Operator::Add, right)),
	<left:OperationExpression> "-" <right:OperationExpression> => Box::new(Expression::Operation(left, Operator::Subtract, right)),
};

CallExpression: Box<Expression> = <expression: SingleExpression> "(" <parameters: ZeroOrMore<SingleExpression>> ")" => Box::new(Expression::Call(expression, parameters));

List: Box<Expression> = <values: OneOrMore<OperationExpression>> => Box::new(Expression::List(values));

OneOrMore<T>: Vec<T> = {
	<mut values: (<T> STOP)+> <last: T> STOP? => {
		values.push(last);
		values
	}
}

ZeroOrMore<T>: Vec<T> = {
	<mut values:(<T> STOP)*> <last: T?> => match last {
		None => values,
		Some(e) => {
			values.push(e);
			values
		}
	}
}

Group: Box<Expression> = "(" <Expression> ")";

Literal: Box<Expression> = {
	Number,
	Identifier,
};

Number: Box<Expression> = <NUMBER> => Box::new(Expression::Number(i32::from_str(<>).unwrap()));

Identifier: Box<Expression> = <IDENTIFIER> => Box::new(Expression::Identifier(String::from(<>)));
