grammar;

use std::str::FromStr;
use crate::ast::*;

match {
	// ignore spaces and tabs
	r"[ \t]*" => { }
} else {
	// precedence of matching tokens
	// in case of ambiguities, longest tokens first
	// else, shortest tokens first
	"*",
	"/",
	"+",
	"-",
	"|",
	"(",
	")",
	"%",
	"==",
	"=",
	"!=",
	"<=",
	">=",
	"<",
	">",
	"::",
	":",
	r"is\s+not" => ISNOT,
	"is",
	"null",
	"true",
	"false",
	"or",
	"and",
	"type",
	"use",
	"namespace",
	r#""[^"]*""# => STRING,
	r"[0-9][0-9_]*\.[0-9_]+" => NUMBER,
	r"[0-9][0-9_]*" => INTEGER,
	r"[,\n]" => STOP,
	r#"[^\s0-9,;:=?./+%`^¨*&'(!)\\\-_"][^\s,;:=?./+%`^¨*&'(!)\\\-_]*"# => IDENTIFIER,
}

pub Program: Program = <values: ZeroOrMore<Statement>> => Program(values);

pub Statement: Statement = {
	<Expression> => Statement::ExpressionStatement(<>),
	TypeDeclaration,
	<Declaration> => Statement::DeclarationStatement(<>),
}


TypeDeclaration: Statement = "type" <identifier: IDENTIFIER> "=" <expression: Expression> => Statement::TypeDeclaration(identifier.to_string(), expression);


Declaration: Declaration = {
	DeclarationWithType,
	DeclarationWithoutType,
}

DeclarationWithType: Declaration = <identifier: IDENTIFIER> <type_expression: (":" <Expression>)> <expression: ("=" <Expression>)> => Declaration {
	identifier: identifier.to_string(),
	type_expression: Some(type_expression),
	expression: Some(expression)
};

DeclarationWithoutType: Declaration = <identifier: IDENTIFIER> <expression: ("=" <Expression>)> => Declaration {
	identifier: identifier.to_string(),
	type_expression: None,
	expression: Some(expression)
};

pub Expression: Box<Expression> = {
	Call,
	LiteralOrOperation,
}

LiteralOrOperation: Box<Expression> = {
	#[precedence(level="0")]
	Literal,
	Group,
	
	#[precedence(level="30")] #[assoc(side="left")]
	<left:LiteralOrOperation> "*" <right:LiteralOrOperation> => Box::new(Expression::OperationExpression(Operation { left, operator: Operator::Multiply, right })),
	<left:LiteralOrOperation> "/" <right:LiteralOrOperation> => Box::new(Expression::OperationExpression(Operation { left, operator: Operator::Divide, right })),
	<left:LiteralOrOperation> "%" <right:LiteralOrOperation> => Box::new(Expression::OperationExpression(Operation { left, operator: Operator::Remainder, right })),

	#[precedence(level="40")] #[assoc(side="left")]
	<left:LiteralOrOperation> "+" <right:LiteralOrOperation> => Box::new(Expression::OperationExpression(Operation { left, operator: Operator::Add, right })),
	<left:LiteralOrOperation> "-" <right:LiteralOrOperation> => Box::new(Expression::OperationExpression(Operation { left, operator: Operator::Subtract, right })),

	#[precedence(level="50")] #[assoc(side="left")]
	<left:LiteralOrOperation> "==" <right:LiteralOrOperation> => Box::new(Expression::OperationExpression(Operation { left, operator: Operator::Equal, right })),
	<left:LiteralOrOperation> "!=" <right:LiteralOrOperation> => Box::new(Expression::OperationExpression(Operation { left, operator: Operator::NotEqual, right })),
	<left:LiteralOrOperation> "<=" <right:LiteralOrOperation> => Box::new(Expression::OperationExpression(Operation { left, operator: Operator::LessThanOrEqual, right })),
	<left:LiteralOrOperation> ">=" <right:LiteralOrOperation> => Box::new(Expression::OperationExpression(Operation { left, operator: Operator::GreaterThanOrEqual, right })),
	<left:LiteralOrOperation> ">" <right:LiteralOrOperation> => Box::new(Expression::OperationExpression(Operation { left, operator: Operator::GreaterThan, right })),
	<left:LiteralOrOperation> "<" <right:LiteralOrOperation> => Box::new(Expression::OperationExpression(Operation { left, operator: Operator::LessThan, right })),
	<left:LiteralOrOperation> "is" <right:LiteralOrOperation> => Box::new(Expression::OperationExpression(Operation { left, operator: Operator::Is, right })),
	<left:LiteralOrOperation> ISNOT <right:LiteralOrOperation> => Box::new(Expression::OperationExpression(Operation { left, operator: Operator::IsNot, right })),

	#[precedence(level="60")] #[assoc(side="left")]
	<left:LiteralOrOperation> "and" <right:LiteralOrOperation> => Box::new(Expression::OperationExpression(Operation { left, operator: Operator::And, right })),

	#[precedence(level="70")] #[assoc(side="left")]
	<left:LiteralOrOperation> "or" <right:LiteralOrOperation> => Box::new(Expression::OperationExpression(Operation { left, operator: Operator::Or, right })),

	#[precedence(level="80")] #[assoc(side="left")]
	<left:LiteralOrOperation> "|" <right:LiteralOrOperation> => Box::new(Expression::OperationExpression(Operation { left, operator: Operator::Union, right })),
};

Call: Box<Expression> = <expression: Expression> "(" <parameters: ZeroOrMore<Expression>> ")" => Box::new(Expression::CallExpression(Call { function: expression, parameters }));

OneOrMore<T>: Vec<T> = {
	<mut values: (<T> STOP)+> <last: T> STOP? => {
		values.push(last);
		values
	}
}

ZeroOrMore<T>: Vec<T> = {
	<mut values:(<T> STOP)*> <last: T?> => match last {
		None => values,
		Some(e) => {
			values.push(e);
			values
		}
	}
}

Group: Box<Expression> = "(" <Expression> ")";

Literal: Box<Expression> = {
	Number,
	Integer,
	Identifier,
	Boolean,
	String,
	Null,
};

Integer: Box<Expression> = <INTEGER> => Box::new(Expression::Integer(i64::from_str(<>).unwrap()));
Number: Box<Expression> = <NUMBER> => Box::new(Expression::Number(f64::from_str(<>).unwrap()));

Identifier: Box<Expression> = <IDENTIFIER> => Box::new(Expression::Identifier(String::from(<>)));

Boolean: Box<Expression> = {
	True,
	False,
}

True: Box<Expression> = <"true"> => Box::new(Expression::Boolean(true));
False: Box<Expression> = <"false"> => Box::new(Expression::Boolean(false));

String: Box<Expression> = <value: STRING> => Box::new(Expression::String(String::from(&value[1..value.len()-1])));

Null: Box<Expression> = <"null"> => Box::new(Expression::Null);
