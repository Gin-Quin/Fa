grammar;

use std::str::FromStr;
use crate::ast::*;

match {
	// ignore spaces and tabs
	r"[ \t]*" => { },
} else {
	// precedence of matching tokens
	// in case of ambiguities, longest tokens first
	// else, most common tokens first
	r"[,\n]\n*" => STOP,
	r"[0-9][0-9_]*\.[0-9_]+" => NUMBER,
	r"[0-9][0-9_]*" => INTEGER,
	r"\*\n*" => STAR,
	r"/\n*" => SLASH,
	r"\+\n*" => PLUS,
	r"-\n*" => MINUS,
	r"\|\n*" => PIPE,
	r"\(\n*" => PARENTHESIS_OPEN,
	r"\n*\)" => PARENTHESIS_CLOSE,
	r"%\n*" => PERCENT,
	r"\{\n*" => BRACKET_OPEN,
	r"\}\n*" => BRACKET_CLOSE,
	r"\[\n*" => SQUARE_BRACKET_OPEN,
	r"\]\n*" => SQUARE_BRACKET_CLOSE,
	r"==\n*" => EQUAL_DOUBLE,
	r"=\n*" => EQUAL,
	r"!=\n*" => NOT_EQUAL,
	r"<=\n*" => LESS_EQUAL,
	r">=\n*" => GREATER_EQUAL,
	r"<\n*" => LESS,
	r">\n*" => GREATER,
	r"=>\n*" => FAT_ARROW,
	r"\n*\." => DOT,
	r"\n*::" => DOUBLE_COLON,
	r":\n*" => COLON,
	r"is\s+not\n*" => ISNOT,
	r"is\n*" => IS,
	"null",
	"true",
	"false",
	r"or\n*" => OR,
	r"and\n*" => AND,
	r"if\n*" => IF,
	r"else\n*" => ELSE,
	r"for\n*" => FOR,
	r"while\n*" => WHILE,
	r"when\n*" => WHEN,
	"type",
	"use",
	"namespace",
	r#""[^"]*""# => STRING,
} else {
	r#"[^\s\n0-9,;:=?./+%`^¨*&'(!)|{}\[\]\\\-_"<>][^\s\n,;:=?./+%`^¨*&'(!)|{}\[\]\\\-_<>]*"# => IDENTIFIER,
}

pub Program: Program = STOP? <ZeroOrMore<Statement>> => <>;

pub Statement: Statement = {
	<Expression> => Statement::Expression(<>),
	TypeDeclaration,
	<Declaration> => Statement::Declaration(<>),
	"use" <Expression> => Statement::Use(<>),
}


TypeDeclaration: Statement = "type" <identifier: IDENTIFIER> EQUAL <expression: Expression> => Statement::TypeDeclaration(identifier.to_string(), expression);

Block: Box<Expression> = BRACKET_OPEN <statements: ZeroOrMore<Statement>> BRACKET_CLOSE => Box::new(Expression::Block(statements));

Array: Box<Expression> = SQUARE_BRACKET_OPEN <fields: ZeroOrMore<Expression>> SQUARE_BRACKET_CLOSE => Box::new(Expression::Array(fields));

Declaration: Declaration = {
	DeclarationWithType, 
	DeclarationWithoutType,
}

DeclarationOrIdentifier: Declaration = {
	DeclarationWithType,
	DeclarationWithoutType,
	<IDENTIFIER> => Declaration {	
		identifier: String::from(<>),
		type_expression: None,
		expression: None,
	},
}

DeclarationWithType: Declaration = <identifier: IDENTIFIER> <type_expression: (COLON <Expression>)> <expression: (EQUAL <Expression>)?> => Declaration {
	identifier: identifier.to_string(),
	type_expression: Some(type_expression),
	expression: expression
};

DeclarationWithoutType: Declaration = <identifier: IDENTIFIER> <expression: (EQUAL <Expression>)> => Declaration {
	identifier: identifier.to_string(),
	type_expression: None,
	expression: Some(expression)
};

pub Expression: Box<Expression> = {
	If,
	Call,
	Index,
	LiteralOrOperation,
}

Branch: Branch = PARENTHESIS_OPEN <condition: Expression> PARENTHESIS_CLOSE <then: Expression> => Box::new(Branch { condition, then });

If: Box<Expression> = IF PARENTHESIS_OPEN <condition: Expression> PARENTHESIS_CLOSE <ok: Expression> <not_ok: Else> => Box::new(Expression::If(condition, ok, not_ok));

Else: Option<Box<Expression>> = {
	ELSE <Expression>,
	// STOP => None,
}

LiteralOrOperation: Box<Expression> = {
	#[precedence(level="5")]
	Literal,
	Group,
	Block,
	Array,

	#[precedence(level="19")] #[assoc(side="left")]
	<left:LiteralOrOperation> DOUBLE_COLON <right:LiteralOrOperation> => Box::new(Expression::Operation { left, operator: Operator::Path, right }),
	
	#[precedence(level="20")] #[assoc(side="left")]
	<left:LiteralOrOperation> DOT <right:LiteralOrOperation> => Box::new(Expression::Operation { left, operator: Operator::MemberAccess, right }),

	#[precedence(level="30")] #[assoc(side="left")]
	<left:LiteralOrOperation> STAR <right:LiteralOrOperation> => Box::new(Expression::Operation { left, operator: Operator::Multiply, right }),
	<left:LiteralOrOperation> SLASH <right:LiteralOrOperation> => Box::new(Expression::Operation { left, operator: Operator::Divide, right }),
	<left:LiteralOrOperation> PERCENT <right:LiteralOrOperation> => Box::new(Expression::Operation { left, operator: Operator::Remainder, right }),

	#[precedence(level="40")] #[assoc(side="left")]
	<left:LiteralOrOperation> PLUS <right:LiteralOrOperation> => Box::new(Expression::Operation { left, operator: Operator::Add, right }),
	<left:LiteralOrOperation> MINUS <right:LiteralOrOperation> => Box::new(Expression::Operation { left, operator: Operator::Subtract, right }),

	#[precedence(level="50")] #[assoc(side="left")]
	<left:LiteralOrOperation> EQUAL_DOUBLE <right:LiteralOrOperation> => Box::new(Expression::Operation { left, operator: Operator::Equal, right }),
	<left:LiteralOrOperation> NOT_EQUAL <right:LiteralOrOperation> => Box::new(Expression::Operation { left, operator: Operator::NotEqual, right }),
	<left:LiteralOrOperation> LESS_EQUAL <right:LiteralOrOperation> => Box::new(Expression::Operation { left, operator: Operator::LessThanOrEqual, right }),
	<left:LiteralOrOperation> GREATER_EQUAL <right:LiteralOrOperation> => Box::new(Expression::Operation { left, operator: Operator::GreaterThanOrEqual, right }),
	<left:LiteralOrOperation> GREATER <right:LiteralOrOperation> => Box::new(Expression::Operation { left, operator: Operator::GreaterThan, right }),
	<left:LiteralOrOperation> LESS <right:LiteralOrOperation> => Box::new(Expression::Operation { left, operator: Operator::LessThan, right }),
	<left:LiteralOrOperation> IS <right:LiteralOrOperation> => Box::new(Expression::Operation { left, operator: Operator::Is, right }),
	<left:LiteralOrOperation> ISNOT <right:LiteralOrOperation> => Box::new(Expression::Operation { left, operator: Operator::IsNot, right }),

	#[precedence(level="60")] #[assoc(side="left")]
	<left:LiteralOrOperation> AND <right:LiteralOrOperation> => Box::new(Expression::Operation { left, operator: Operator::And, right }),

	#[precedence(level="70")] #[assoc(side="left")]
	<left:LiteralOrOperation> OR <right:LiteralOrOperation> => Box::new(Expression::Operation { left, operator: Operator::Or, right }),

	#[precedence(level="80")] #[assoc(side="left")]
	<left:LiteralOrOperation> PIPE <right:LiteralOrOperation> => Box::new(Expression::Operation { left, operator: Operator::Union, right }),

	#[precedence(level="100")] #[assoc(side="left")]
	Function,
};

Call: Box<Expression> = <expression: Expression> PARENTHESIS_OPEN <parameters: ZeroOrMore<Expression>> PARENTHESIS_CLOSE => Box::new(Expression::Call { function: expression, parameters });

Index: Box<Expression> = <expression: Expression> SQUARE_BRACKET_OPEN <index: Expression> SQUARE_BRACKET_CLOSE => Box::new(Expression::Index { expression, index });

Function: Box<Expression> = PARENTHESIS_OPEN <parameters: ZeroOrMore<Declaration>> PARENTHESIS_CLOSE FAT_ARROW <body:LiteralOrOperation> => Box::new(Expression::Function { parameters, body });

OneOrMore<T>: Vec<T> = {
	<mut values: (<T> STOP)+> <last: T> STOP? => {
		values.push(last);
		values
	}
}

ZeroOrMore<T>: Vec<T> = {
	<mut values:(<T> STOP)*> <last: T?> => match last {
		None => values,
		Some(e) => {
			values.push(e);
			values
		}
	}
}

Group: Box<Expression> = PARENTHESIS_OPEN <Expression> PARENTHESIS_CLOSE;

Literal: Box<Expression> = {
	Number,
	Integer,
	Identifier,
	Boolean,
	String,
	Null,
};

Integer: Box<Expression> = <INTEGER> => Box::new(Expression::Integer(i64::from_str(<>).unwrap()));
Number: Box<Expression> = <NUMBER> => Box::new(Expression::Number(f64::from_str(<>).unwrap()));

Identifier: Box<Expression> = <IDENTIFIER> => Box::new(Expression::Identifier(String::from(<>)));

Boolean: Box<Expression> = {
	True,
	False,
}

True: Box<Expression> = <"true"> => Box::new(Expression::Boolean(true));
False: Box<Expression> = <"false"> => Box::new(Expression::Boolean(false));

String: Box<Expression> = <value: STRING> => Box::new(Expression::String(String::from(&value[1..value.len()-1])));

Null: Box<Expression> = <"null"> => Box::new(Expression::Null);
